{"version":3,"sources":["chunk-chute.min.js"],"names":["create","Class","ChunkChute","callback","source","exec","context","issue","resolve","reject","push","args","arguments","pipes","forEach","pipe","apply","stack","shift","process","Promise","then","proceed","pull","this","resolved","rejected","chute","fork","filter","Array","prototype","slice","call","extend","Object","defineProperty","get","set","enumerable","configurable","promise","res","rej","join","isDone","isFail","isOpen","sources","every","some","all","race","map","module","exports","window","Error","name"],"mappings":"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","file":"chunk-chute.min.js","sourcesContent":["/*!\n * chunk-chute\n * Cascading chunks of data (promises) and transform them into one or multiple outputs.\n *\n * @version v0.0.0\n * @link https://github.com/orianda/chunk-chute\n * @author Orianda <orianda@paan.de>\n * @license MIT\n */\n(function (create) {\r\n  'use strict';\r\n\r\n  var Class = create();\r\n\r\n  if (typeof module === 'object' && module instanceof Object && module.exports instanceof Object) {\r\n    module.exports = Class;\r\n  } else if (typeof window === 'object' && window instanceof Object) {\r\n    window[Class.name] = Class;\r\n  } else {\r\n    throw new Error('No valid context available.');\r\n  }\r\n\r\n})(function () {\r\n  'use strict';\r\n\r\n  /**\r\n   * Create chunk chute instance\r\n   * @param {Function} callback\r\n   * @param {ChunkChute} [source]\r\n   * @constructor\r\n   */\r\n  function ChunkChute(callback, source) {\r\n    var chute, stack, pipes, process, promise, resolve, reject, resolved, rejected;\r\n\r\n    /**\r\n     * Execute chunk\r\n     * @returns {Promise}\r\n     */\r\n    function exec() {\r\n      var context, issue;\r\n\r\n      context = {\r\n        resolve: resolve,\r\n        reject: reject,\r\n        push: function () {\r\n          var args = arguments;\r\n          pipes.forEach(function (pipe) {\r\n            pipe.push.apply(pipe, args);\r\n          });\r\n        }\r\n      };\r\n\r\n      issue = callback.apply(context, stack.shift());\r\n\r\n      process = Promise.resolve(issue).then(function (proceed) {\r\n        process = null;\r\n        pipes.forEach(function (pipe) {\r\n          /** @type {ChunkChute} */\r\n          pipe.pull();\r\n        });\r\n\r\n        if (proceed) {\r\n          pull();\r\n        }\r\n      });\r\n      return process;\r\n    }\r\n\r\n    /**\r\n     * Push arguments\r\n     * @this {ChunkChute}\r\n     * @returns {ChunkChute}\r\n     */\r\n    function push() {\r\n      stack.push(arguments);\r\n      return this;\r\n    }\r\n\r\n    /**\r\n     * Execute item\r\n     * @returns {Promise}\r\n     */\r\n    function pull() {\r\n      if (resolved || rejected) {\r\n        return Promise.resolve();\r\n      }\r\n\r\n      if (process) {\r\n        return process;\r\n      }\r\n\r\n      if (stack[0]) {\r\n        return exec();\r\n      }\r\n\r\n      if (!source) {\r\n        stack.push([]);\r\n        return pull();\r\n      }\r\n\r\n      if (source.resolved || source.rejected) {\r\n        source.then(resolve, reject);\r\n        return Promise.resolve();\r\n      }\r\n\r\n      process = source.pull().then(function () {\r\n        process = null;\r\n        return pull();\r\n      }, reject);\r\n      return process;\r\n    }\r\n\r\n    /**\r\n     * Add pipe\r\n     * @param {Function} callback\r\n     * @returns {ChunkChute}\r\n     */\r\n    function pipe(callback) {\r\n      var pipe = new ChunkChute(callback, chute);\r\n      pipes.push(pipe);\r\n      return pipe;\r\n    }\r\n\r\n    /**\r\n     * Split the chunk chute\r\n     * @param {Function} filter\r\n     * @returns {ChunkChute}\r\n     */\r\n    function fork(filter) {\r\n      return chute.pipe(function () {\r\n        var args = Array.prototype.slice.call(arguments);\r\n        if (filter.apply(null, args)) {\r\n          this.push.apply(this, args);\r\n        }\r\n      });\r\n    }\r\n\r\n    /**\r\n     * Extends object by chute functions\r\n     * @param {Object} context\r\n     */\r\n    function extend(context) {\r\n      var then = context.then;\r\n\r\n      /**\r\n       * Extend then to ensure the created promise does have the chute functions\r\n       * @param {Function} [resolved]\r\n       * @param {Function} [rejected]\r\n       * @returns {Promise}\r\n       */\r\n      context.then = function (resolved, rejected) {\r\n        var promise = then.call(context, resolved, rejected);\r\n        return extend(promise);\r\n      };\r\n\r\n      context.push = push;\r\n      context.pull = pull;\r\n      context.pipe = pipe;\r\n      context.fork = fork;\r\n\r\n      Object.defineProperty(context, 'resolved', {\r\n        get: function () {\r\n          return resolved;\r\n        },\r\n        set: function () {\r\n        },\r\n        enumerable: true,\r\n        configurable: false\r\n      });\r\n      Object.defineProperty(context, 'rejected', {\r\n        get: function () {\r\n          return rejected;\r\n        },\r\n        set: function () {\r\n        },\r\n        enumerable: true,\r\n        configurable: false\r\n      });\r\n\r\n      return context;\r\n    }\r\n\r\n    /**\r\n     * Ensure instance was created using new operator\r\n     */\r\n    if (!(this instanceof ChunkChute)) {\r\n      return new ChunkChute(callback, source);\r\n    }\r\n\r\n    /**\r\n     * Store context for nested usage\r\n     * @type {ChunkChute}\r\n     */\r\n    chute = this;\r\n\r\n    /**\r\n     * Incoming stack\r\n     * @type {Array}\r\n     */\r\n    stack = [];\r\n\r\n    /**\r\n     * Pipe stack\r\n     * @type {ChunkChute[]}\r\n     */\r\n    pipes = [];\r\n\r\n    /**\r\n     * Represent final state by promise\r\n     * @type {Promise}\r\n     */\r\n    promise = new Promise(function (res, rej) {\r\n      resolve = res;\r\n      reject = rej;\r\n    });\r\n\r\n    /**\r\n     * Make promise status available\r\n     */\r\n    resolved = false;\r\n    rejected = false;\r\n    promise.then(function () {\r\n      resolved = true;\r\n    }, function () {\r\n      rejected = true;\r\n    });\r\n\r\n    /**\r\n     * Make chute thenable\r\n     * @param {Function} [resolved]\r\n     * @param {Function} [rejected]\r\n     * @returns {Promise}\r\n     */\r\n    this.then = function (resolved, rejected) {\r\n      return promise.then(resolved, rejected);\r\n    };\r\n\r\n    extend(this);\r\n  }\r\n\r\n  /**\r\n   * Join multiple chunk chutes\r\n   * @returns {ChunkChute}\r\n   */\r\n  ChunkChute.join = function () {\r\n    var sources, chute;\r\n\r\n    /**\r\n     * Is chute finished?\r\n     * @param {ChunkChute} chute\r\n     * @returns {boolean}\r\n     */\r\n    function isDone(chute) {\r\n      return chute.resolved || chute.rejected;\r\n    }\r\n\r\n    /**\r\n     * Has chute failed?\r\n     * @param {ChunkChute} chute\r\n     * @returns {boolean}\r\n     */\r\n    function isFail(chute) {\r\n      return chute.rejected;\r\n    }\r\n\r\n    /**\r\n     * Is chute still active?\r\n     * @param {ChunkChute} chute\r\n     * @returns {boolean}\r\n     */\r\n    function isOpen(chute) {\r\n      return !isDone(chute);\r\n    }\r\n\r\n    /**\r\n     * Pull from chute\r\n     * @param {ChunkChute} chute\r\n     * @returns {Promise}\r\n     */\r\n    function pull(chute) {\r\n      return chute.pull();\r\n    }\r\n\r\n    /**\r\n     * Every argument is a chute\r\n     * @type {ChunkChute[]}\r\n     */\r\n    sources = Array.prototype.slice.call(arguments);\r\n\r\n    /**\r\n     * Join chutes\r\n     * @type {ChunkChute}\r\n     */\r\n    chute = new ChunkChute(function () {\r\n      this.push.apply(this, arguments);\r\n    }, new ChunkChute(function () {\r\n      if (sources.every(isDone) || sources.some(isFail)) {\r\n        return Promise.all(sources).then(this.resolve, this.reject);\r\n      } else {\r\n        return Promise.race(sources.filter(isOpen).map(pull));\r\n      }\r\n    }));\r\n\r\n    /**\r\n     * Forward push\r\n     */\r\n    sources = sources.map(function (source) {\r\n      return source.pipe(function () {\r\n        chute.push.apply(chute, arguments);\r\n      });\r\n    });\r\n\r\n    return chute;\r\n  };\r\n\r\n  return ChunkChute;\r\n});"]}